import React, { useEffect, useMemo, useRef, useState } from "react"; import { Card, CardContent } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import { Input } from "@/components/ui/input"; import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs"; import { Badge } from "@/components/ui/badge"; import { Select, SelectTrigger, SelectContent, SelectItem, SelectValue } from "@/components/ui/select"; import { Textarea } from "@/components/ui/textarea"; import { ScrollArea } from "@/components/ui/scroll-area"; import { Separator } from "@/components/ui/separator"; import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"; import { Trash2, Save, Play, Plus, Delete, RotateCcw, Sigma, Settings2 } from "lucide-react"; import * as math from "mathjs";

/**

Nova SuperCalc — a comprehensive scientific calculator with:

Full scientific keypad (trig, hyperbolic, logs, roots, nPr/nCr, mod, %, factorial, constants, Ans, memory)


Degrees/Radians toggle


History tape


User formulas:


• JS Expression mode powered by math.js

• Python mode powered by Pyodide (loaded in-browser)

Parameter forms & quick run


LocalStorage persistence


Tips:

You can type directly: e.g. sin(30)+3^2 (switch DEG/RAD as needed)


Use built-ins: pi, e, tau, mod, sqrt(), log(), ln(x) as log(x), log10(x)


nPr/nCr: use nPr(n,r), nCr(n,r) or buttons


Random: rand() in [0,1), randint(a,b)


Percent: 50% becomes 0.5; 200*10% = 20


Factorial: 5! or gamma(n+1) via button


Memory: MC, MR, M+, M-


Formulas tab: save named formulas (JS or Python), then run them with parameters. */



const DEG = "DEG" as const; const RAD = "RAD" as const;

// Helper: wrap trig to support degree mode const withAngleMode = (expr: string, mode: typeof DEG | typeof RAD) => { if (mode === RAD) return expr; // Convert trig function arguments from deg->rad and inverse from rad->deg // We transform tokens like sin( -> sin(toRad( // and asin( -> toDeg(asin( const toRad = (s: string) => s .replace(/(?<![A-Za-z0-9_])sin(/g, "sin(toRad(") .replace(/(?<![A-Za-z0-9_])cos(/g, "cos(toRad(") .replace(/(?<![A-Za-z0-9_])tan(/g, "tan(toRad(") .replace(/(?<![A-Za-z0-9_])sinh(/g, "sinh(toRad(") .replace(/(?<![A-Za-z0-9_])cosh(/g, "cosh(toRad(") .replace(/(?<![A-Za-z0-9_])tanh(/g, "tanh(toRad("); const toDeg = (s: string) => s .replace(/(?<![A-Za-z0-9_])asin(/g, "toDeg(asin(") .replace(/(?<![A-Za-z0-9_])acos(/g, "toDeg(acos(") .replace(/(?<![A-Za-z0-9_])atan(/g, "toDeg(atan(") .replace(/(?<![A-Za-z0-9_])asinh(/g, "toDeg(asinh(") .replace(/(?<![A-Za-z0-9_])acosh(/g, "toDeg(acosh(") .replace(/(?<![A-Za-z0-9_])atanh(/g, "toDeg(atanh("); return toDeg(toRad(expr)); };

// Provide helpers to math.js scope const buildScope = (extra: Record<string, any> = {}, angleMode: typeof DEG | typeof RAD = RAD) => { const toRad = (x: number) => (x * Math.PI) / 180; const toDeg = (x: number) => (x * 180) / Math.PI; const randint = (a: number, b: number) => Math.floor(Math.random() * (b - a + 1)) + a; const nPr = (n: number, r: number) => math.factorial(n) / math.factorial(n - r); const nCr = (n: number, r: number) => math.combinations(n, r); const tau = 2 * Math.PI; return { ...extra, pi: Math.PI, e: Math.E, tau, toRad, toDeg, randint, nPr, nCr, log10: (x: number) => Math.log10(x), ln: (x: number) => Math.log(x), // percent helper: 10% => 0.1; used during tokenization but exposed too pct: (x: number) => x / 100, }; };

// Safe stringify of errors const errMsg = (e: any) => (e && e.message) ? e.message : String(e);

// Storage helpers const LS_KEYS = { formulas: "nova_supercalc_formulas_v1", mem: "nova_supercalc_memory_v1", mode: "nova_supercalc_mode_v1", history: "nova_supercalc_history_v1", };

// Types type Formula = { id: string; name: string; lang: "js" | "py"; params: string[]; // ["a","b",...] body: string; // expression (js) or python function body returning a value };

export default function NovaSuperCalc() { const [display, setDisplay] = useState<string>(""); const [angleMode, setAngleMode] = useState<typeof DEG | typeof RAD>(() => (localStorage.getItem(LS_KEYS.mode) as any) || DEG); const [ans, setAns] = useState<number>(0); const [memory, setMemory] = useState<number>(() => Number(localStorage.getItem(LS_KEYS.mem) || 0)); const [history, setHistory] = useState<string[]>(() => { try { return JSON.parse(localStorage.getItem(LS_KEYS.history) || "[]"); } catch { return []; } });

// Formula state const [formulas, setFormulas] = useState<Formula[]>(() => { try { return JSON.parse(localStorage.getItem(LS_KEYS.formulas) || "[]"); } catch { return []; } }); const [activeFormula, setActiveFormula] = useState<Partial<Formula>>({ lang: "js", name: "", params: [], body: "" }); const [pyodide, setPyodide] = useState<any>(null); const [pyReady, setPyReady] = useState<boolean>(false);

// Load Pyodide lazily useEffect(() => { let cancelled = false; async function loadPy() { try { // @ts-ignore const { loadPyodide } = await import("https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"); const py = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/" }); if (!cancelled) { setPyodide(py); setPyReady(true); } } catch (e) { console.error("Pyodide load error", e); } } loadPy(); return () => { cancelled = true; }; }, []);

useEffect(() => { localStorage.setItem(LS_KEYS.mode, angleMode); }, [angleMode]); useEffect(() => { localStorage.setItem(LS_KEYS.mem, String(memory)); }, [memory]); useEffect(() => { localStorage.setItem(LS_KEYS.history, JSON.stringify(history.slice(-200))); }, [history]); useEffect(() => { localStorage.setItem(LS_KEYS.formulas, JSON.stringify(formulas)); }, [formulas]);

// Key handling (simple) useEffect(() => { const onKey = (e: KeyboardEvent) => { const k = e.key; if (/[0-9.]/.test(k)) setDisplay(d => d + k); else if (k === "+" || k === "-" || k === "*" || k === "/" || k === "^") setDisplay(d => d + k); else if (k === "(") setDisplay(d => d + "("); else if (k === ")") setDisplay(d => d + ")"); else if (k === "Enter" || k === "=") { e.preventDefault(); doEval(); } else if (k === "Backspace") setDisplay(d => d.slice(0, -1)); else if (k === "Escape") setDisplay(""); }; window.addEventListener("keydown", onKey); return () => window.removeEventListener("keydown", onKey); }, [angleMode, ans]);

const push = (txt: string) => setDisplay(d => d + txt);

const tokenFixups = (input: string) => { let s = input.trim(); if (!s) return s; // Replace percent occurrences: e.g. 10% -> pct(10) s = s.replace(/(\d+(?:.\d+)?)%/g, "pct($1)"); // Allow Ans, MEM s = s.replace(/\bAns\b/g, String(ans)); s = s.replace(/\bMEM\b/g, String(memory)); // Allow ^ as power for math.js // Already ok in math.js return s; };

const doEval = () => { try { let expr = tokenFixups(display); expr = withAngleMode(expr, angleMode); const scope = buildScope({}, angleMode); const res = math.evaluate(expr, scope as any); const val = (typeof res === "number") ? res : (res?.valueOf?.() ?? res); setAns(Number(val)); setHistory(h => [...h, ${display} = ${val}]); setDisplay(String(val)); } catch (e) { setHistory(h => [...h, ${display} = Error: ${errMsg(e)}]); } };

const clearAll = () => setDisplay(""); const backspace = () => setDisplay(d => d.slice(0, -1));

// Button layout const rows: { label: string, on?: () => void, insert?: string, hint?: string }[][] = [ [ { label: "MC", on: () => setMemory(0), hint: "Memory Clear" }, { label: "MR", on: () => setDisplay(d => d + (Number(memory))), hint: "Memory Recall" }, { label: "M+", on: () => { try { setMemory(m => m + Number(math.evaluate(tokenFixups(display) || "0", buildScope()))); } catch {} } }, { label: "M-", on: () => { try { setMemory(m => m - Number(math.evaluate(tokenFixups(display) || "0", buildScope()))); } catch {} } }, { label: angleMode, on: () => setAngleMode(m => m === DEG ? RAD : DEG), hint: "Toggle Degree/Radian" }, { label: "Ans", insert: "Ans" }, { label: "+/-", on: () => setDisplay(d => d ? (d.startsWith("-") ? d.slice(1) : "-" + d) : d) }, { label: "C", on: clearAll }, { label: "⌫", on: backspace }, ], [ { label: "sin", insert: "sin(" }, { label: "cos", insert: "cos(" }, { label: "tan", insert: "tan(" }, { label: "asin", insert: "asin(" }, { label: "acos", insert: "acos(" }, { label: "atan", insert: "atan(" }, { label: "sinh", insert: "sinh(" }, { label: "cosh", insert: "cosh(" }, { label: "tanh", insert: "tanh(" }, ], [ { label: "π", insert: "pi" }, { label: "e", insert: "e" }, { label: "τ", insert: "tau" }, { label: "^", insert: "^" }, { label: "√", insert: "sqrt(" }, { label: "∛", insert: "nthRoot(" }, { label: "x²", insert: "^2" }, { label: "x³", insert: "^3" }, { label: "x⁻¹", insert: "^(-1)" }, ], [ { label: "log", insert: "log(" }, { label: "log10", insert: "log10(" }, { label: "ln", insert: "ln(" }, { label: "!", insert: "!" }, { label: "%", insert: "%" }, { label: "mod", insert: " mod " }, { label: "nPr", insert: "nPr(" }, { label: "nCr", insert: "nCr(" }, { label: "rand", insert: "rand()" }, ], [ { label: "7", insert: "7" }, { label: "8", insert: "8" }, { label: "9", insert: "9" }, { label: "/", insert: "/" }, { label: "(", insert: "(" }, { label: ")", insert: ")" }, { label: ",", insert: "," }, { label: "MEM", insert: "MEM" }, { label: "=", on: doEval }, ], [ { label: "4", insert: "4" }, { label: "5", insert: "5" }, { label: "6", insert: "6" }, { label: "", insert: "" }, { label: "-", insert: "-" }, { label: "+", insert: "+" }, { label: "0", insert: "0" }, { label: "1", insert: "1" }, { label: "2", insert: "2" }, ], [ { label: "3", insert: "3" }, { label: ".", insert: "." }, { label: "^r", insert: "^(" }, { label: "exp", insert: "exp(" }, { label: "min", insert: "min(" }, { label: "max", insert: "max(" }, { label: "sum", insert: "sum(" }, { label: "avg", insert: "mean(" }, { label: "=", on: doEval }, ], ];

const onBtn = (b: { label: string, on?: () => void, insert?: string }) => { if (b.on) return b.on(); if (b.insert) return push(b.insert); };

// Formula helpers const newFormula = () => setActiveFormula({ id: undefined, name: "", lang: "js", params: [], body: "" }); const saveFormula = () => { const f: Formula = { id: activeFormula?.id || crypto.randomUUID(), name: (activeFormula?.name || "").trim() || Formula_${formulas.length + 1}, lang: (activeFormula?.lang as any) || "js", params: (activeFormula?.params || []) as string[], body: activeFormula?.body || "", }; setFormulas(prev => { const ix = prev.findIndex(x => x.id === f.id); if (ix >= 0) { const cp = [...prev]; cp[ix] = f; return cp; } return [...prev, f]; }); setActiveFormula({ ...f }); }; const deleteFormula = (id: string) => { setFormulas(prev => prev.filter(f => f.id !== id)); if (activeFormula?.id === id) setActiveFormula({ lang: "js", name: "", params: [], body: "" }); };

const runFormula = async (f: Formula, paramValues: Record<string, any>) => { try { if (f.lang === "js") { const scope = buildScope(paramValues, angleMode); const expr = withAngleMode(tokenFixups(f.body), angleMode); const result = math.evaluate(expr, scope as any); return typeof result === "number" ? result : (result?.valueOf?.() ?? result); } else { if (!pyReady || !pyodide) throw new Error("Python engine not ready"); // Build Python code that defines parameters in local scope and evaluates body const assignments = Object.entries(paramValues).map(([k, v]) => ${k} = ${JSON.stringify(v)}).join("\n"); const code = ${assignments}\n\nimport math\nfrom math import pi, e\n\n# Helper functions matching JS scope\nfrom math import sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh, sqrt, log, exp\n\n# Degrees helpers\nimport math\n def toRad(x):\n    return (x*math.pi)/180.0\n\n def toDeg(x):\n    return (x*180.0)/math.pi\n\n# Combinatorics\nimport math as _m\n def nPr(n,r):\n    return math.factorial(n)//math.factorial(n-r)\n\n def nCr(n,r):\n    return math.comb(n,r)\n\n# Percent helper\n def pct(x):\n    return x/100.0\n\n# randint helper\nimport random\n def randint(a,b):\n    return random.randint(int(a), int(b))\n\n# User body must assign to _out or be an expression. We'll try eval first. _out = None try: _out = (${f.body}) except Exception: pass if _out is None: # execute as statements, expecting _out set by user or last expression captured def _run(): ${f.body.split("\n").map((line)=>line).join("\n        ")} _run() # _out must be set in body _out ; const result = await pyodide.runPythonAsync(code); return result; } } catch (e) { throw e; } };

// UI for running a formula const FormulaRunner: React.FC<{ f: Formula }> = ({ f }) => { const [vals, setVals] = useState<Record<string, any>>(() => Object.fromEntries((f.params||[]).map(p => [p, ""]))); const [out, setOut] = useState<string>(""); const [busy, setBusy] = useState(false);

const go = async () => {
  setBusy(true); setOut("");
  try {
    const parsed: Record<string, any> = {};
    for (const p of f.params) parsed[p] = Number(vals[p]);
    const res = await runFormula(f, parsed);
    setOut(String(res));
  } catch (e) {
    setOut("Error: " + errMsg(e));
  } finally { setBusy(false); }
};

return (
  <Card className="p-3">
    <div className="flex items-center justify-between">
      <div className="font-semibold">{f.name} <Badge variant="secondary" className="ml-2">{f.lang.toUpperCase()}</Badge></div>
      <div className="text-xs text-muted-foreground">params: ({f.params.join(", ")})</div>
    </div>
    <div className="grid grid-cols-2 gap-2 mt-3">
      {f.params.map(p => (
        <div key={p} className="flex items-center gap-2">
          <Badge variant="outline" className="min-w-14 justify-center">{p}</Badge>
          <Input inputMode="decimal" value={vals[p]} onChange={e => setVals(v => ({ ...v, [p]: e.target.value }))} placeholder="value" />
        </div>
      ))}
    </div>
    <div className="flex gap-2 mt-3">
      <Button onClick={go} disabled={busy}><Play className="w-4 h-4 mr-2" />Run</Button>
      <Button variant="destructive" onClick={() => setOut("")}>Clear Output</Button>
    </div>
    {out && <div className="mt-3 p-2 rounded-lg bg-muted"><span className="text-xs text-muted-foreground">Output:</span>
      <div className="font-mono break-all">{out}</div></div>}
  </Card>
);

};

return ( <div className="w-full min-h-[100vh] bg-gradient-to-b from-slate-50 to-white p-4 grid gap-4 lg:grid-cols-2"> {/* Calculator Panel */} <Card className="shadow-md"> <CardContent className="p-4"> <div className="flex items-center justify-between mb-2"> <div className="text-xl font-semibold flex items-center gap-2"><Sigma className="w-5 h-5"/> Nova SuperCalc</div> <div className="text-xs text-muted-foreground">Scientific • JS & Python formulas</div> </div> <Input className="text-right text-2xl py-6 font-mono" value={display} onChange={e => setDisplay(e.target.value)} placeholder="Type or use buttons…"/> <div className="grid grid-cols-9 gap-2 mt-4"> {rows.flat().map((b, i) => ( <Button key={i} variant={b.label === "=" ? "default" : "secondary"} className="h-12 text-sm" onClick={() => onBtn(b)} title={b.hint || b.label}>{b.label}</Button> ))} </div> <div className="flex gap-2 mt-3"> <Button onClick={doEval} className="flex-1"><Play className="w-4 h-4 mr-2"/>Evaluate</Button> <Button variant="outline" onClick={() => setDisplay("") } className="flex-1"><RotateCcw className="w-4 h-4 mr-2"/>Reset</Button> </div> <Separator className="my-3"/> <div className="text-sm font-medium mb-2">History</div> <ScrollArea className="h-40 border rounded-lg p-2 bg-muted/30"> <div className="space-y-1 font-mono text-sm"> {history.slice().reverse().map((h, i) => ( <div key={i} className="flex justify-between gap-2"><span className="truncate">{h}</span></div> ))} </div> </ScrollArea> </CardContent> </Card>

{/* Formulas Panel */}
  <Card className="shadow-md">
    <CardContent className="p-4">
      <div className="flex items-center justify-between mb-2">
        <div className="text-xl font-semibold flex items-center gap-2"><Settings2 className="w-5 h-5"/> Formulas</div>
        <div className="text-xs text-muted-foreground">Saved locally • {pyReady ? "Python ready" : "Python loading…"}</div>
      </div>

      <Tabs defaultValue="manage" className="w-full">
        <TabsList>
          <TabsTrigger value="manage">Manage</TabsTrigger>
          <TabsTrigger value="run">Run</TabsTrigger>
        </TabsList>

        <TabsContent value="manage" className="mt-3">
          <div className="grid lg:grid-cols-2 gap-4">
            <Card className="p-3">
              <div className="text-sm font-medium mb-2">Create / Edit</div>
              <div className="grid gap-2">
                <Input placeholder="Formula name (e.g., hypotenuse)" value={activeFormula?.name || ""} onChange={e => setActiveFormula(f => ({ ...f, name: e.target.value }))} />
                <div className="flex items-center gap-2">
                  <Select value={(activeFormula?.lang as any) || "js"} onValueChange={(v) => setActiveFormula(f => ({ ...f, lang: v as any }))}>
                    <SelectTrigger className="w-40"><SelectValue placeholder="Language" /></SelectTrigger>
                    <SelectContent>
                      <SelectItem value="js">JS (math.js)</SelectItem>
                      <SelectItem value="py">Python (Pyodide)</SelectItem>
                    </SelectContent>
                  </Select>
                  <Input placeholder="Parameters (comma-separated, e.g., a,b)" value={(activeFormula?.params || []).join(",")} onChange={e => setActiveFormula(f => ({ ...f, params: e.target.value.split(",").map(s => s.trim()).filter(Boolean) }))} />
                </div>
                <Textarea rows={8} placeholder={((activeFormula?.lang||"js")==="js") ? "Enter a JS math expression (e.g., sqrt(a^2 + b^2))" : "Enter Python expression or statements assigning to _out\nExample (expression): sqrt(a**2 + b**2)\nExample (statements):\n_c = a**2 + b**2\n_out = _c**0.5"} value={activeFormula?.body || ""} onChange={e => setActiveFormula(f => ({ ...f, body: e.target.value }))} />
                <div className="flex gap-2">
                  <Button onClick={saveFormula}><Save className="w-4 h-4 mr-2"/>Save</Button>
                  <Button variant="outline" onClick={newFormula}><Plus className="w-4 h-4 mr-2"/>New</Button>
                </div>
              </div>
            </Card>

            <Card className="p-3">
              <div className="text-sm font-medium mb-2">Saved</div>
              <ScrollArea className="h-72 border rounded-md p-2 bg-muted/30">
                <div className="space-y-2">
                  {formulas.length === 0 && <div className="text-sm text-muted-foreground">No formulas yet. Create one on the left.</div>}
                  {formulas.map(f => (
                    <div key={f.id} className="p-2 rounded-md bg-white shadow-sm border">
                      <div className="flex items-center justify-between">
                        <div>
                          <div className="font-medium">{f.name} <Badge variant="secondary" className="ml-2">{f.lang.toUpperCase()}</Badge></div>
                          <div className="text-xs text-muted-foreground">({f.params.join(", ")})</div>
                        </div>
                        <div className="flex gap-2">
                          <Button variant="outline" size="sm" onClick={() => setActiveFormula(f)}>Edit</Button>
                          <Button variant="destructive" size="sm" onClick={() => deleteFormula(f.id)}><Trash2 className="w-4 h-4"/></Button>
                        </div>
                      </div>
                      <div className="mt-2 text-xs font-mono whitespace-pre-wrap break-words">{f.body}</div>
                    </div>
                  ))}
                </div>
              </ScrollArea>
            </Card>
          </div>
        </TabsContent>

        <TabsContent value="run" className="mt-3">
          <div className="grid gap-3">
            {formulas.length === 0 && <div className="text-sm text-muted-foreground">No formulas saved. Create one in Manage tab.</div>}
            {formulas.map(f => (
              <FormulaRunner key={f.id} f={f} />
            ))}
          </div>
        </TabsContent>
      </Tabs>
    </CardContent>
  </Card>
</div>

); }

